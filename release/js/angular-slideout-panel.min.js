'use strict';

angular.module('angular-slideout-panel', []);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

angular.module('angular-slideout-panel').service('angularSlideOutPanel', ['$q', '$rootScope', '$timeout', '$http', '$compile', '$controller', 'angularSlideOutPanelStack', function ($q, $rootScope, $timeout, $http, $compile, $controller, angularSlideOutPanelStack) {
  var AngularSlideOutPanel = function () {
    function AngularSlideOutPanel() {
      _classCallCheck(this, AngularSlideOutPanel);
    }

    _createClass(AngularSlideOutPanel, [{
      key: 'open',

      /**
       * @param {Object} [options]
       * @param {String} [options.templateUrl]
       * @param {String} [options.template]
       * @param {String} [options.openOn] - 'left' or 'right' - defaults to 'left'
       */
      value: function open(options) {
        if (!options) throw new Error('angularSlideOutPanel - open() - options is required');
        if (!options.templateUrl && !options.template) throw new Error('angularSlideOutPanel - open() - options.templateUrl or options.template is required');

        options.openOn = options.openOn && (options.openOn === 'right' || options.openOn === 'left') ? options.openOn : 'left';

        //TODO: handle errors getting templates,

        var panelInstance = _createPanel(options);

        var templatePromise = options.templateUrl ? _getTemplate(options.templateUrl) : $q.resolve(options.template);

        templatePromise.then(function (template) {
          panelInstance._init(template);
        });

        return panelInstance;
      }
    }]);

    return AngularSlideOutPanel;
  }();

  var Panel = function () {
    /**
     * @param {Object} options
     * @param {String} [options.templateUrl]
     * @param {String} [options.template]
     * @param {String} [options.openOn]
     * @param {String|Function|Array} [options.controller]
     */
    function Panel(options) {
      _classCallCheck(this, Panel);

      if (!options) throw new Error('Panel - constructor() - options is required');

      this._deferred = $q.defer();
      this.result = this._deferred.promise;

      this.templateUrl = options.templateUrl;
      this.template = options.template;
      this.openOn = options.openOn;
      this.controller = options.controller;

      this._elements = _createPanelElements({
        openOn: this.openOn,
        close: this.close.bind(this),
        dismiss: this.dismiss.bind(this)
      });
    }

    _createClass(Panel, [{
      key: '_init',
      value: function _init(template) {
        var newScope = _getControllerScope(this.controller);
        newScope.$panel = this; //add the Panel instance to the scope so it can be closed from whatever controller the user provides

        var compiledElement = _createTemplate(newScope, template);

        this._elements.modalContentElement.append(compiledElement);

        openModalElements(this._elements.modalElement, this._elements.modalBgElement);
      }
    }, {
      key: 'close',
      value: function close(result) {
        closeModalElements(this._elements.modalElement, this._elements.modalBgElement);

        this._deferred.resolve(result);
      }
    }, {
      key: 'dismiss',
      value: function dismiss(reason) {
        closeModalElements(this._elements.modalElement, this._elements.modalBgElement);

        this._deferred.reject(reason);
      }
    }]);

    return Panel;
  }();

  /**
   * @param {Object} [options]
   * @param {String} [options.openOn] - 'left' or 'right' - defaults to 'left'
   */


  function _createPanel(template, options) {
    return new Panel(template, options);
  }

  function _getControllerScope(controller) {
    var newScope = $rootScope.$new();

    $controller(controller, {
      $scope: newScope
    });

    return newScope;
  }

  /**
   * @param {Object} [options]
   * @param {String} [options.openOn] - 'left' or 'right' - defaults to 'left'
   * @param {Function} [options.close] - close the modal and resolve the promise
   * @param {Function} [options.dismiss] - close the modal and reject the promise
   */
  function _createPanelElements(options) {
    options = options || {};

    var modalElement = angular.element(document.createElement('div'));
    modalElement.addClass('angular-panel');

    var modalBgElement = getOrCreateModalBgElement(modalElement, options);

    var modalDialogElement = angular.element(document.createElement('div'));
    modalDialogElement.addClass('angular-panel-dialog');
    modalDialogElement.on('click', function (event) {
      event.stopPropagation(); //prevent a click on the modal from closing it
    });

    var modalContentElement = angular.element(document.createElement('div'));
    modalContentElement.addClass('angular-panel-content');

    // let modalCloseElement = angular.element(document.createElement('div'));
    // modalCloseElement.addClass('angular-panel-close');
    // modalCloseElement.on('click', (event) => { //close the modal on close button click
    //   if (event) event.preventDefault();
    //
    //   if (options.dismiss) options.dismiss('backdrop click');
    // });

    var modalCloseAElement = angular.element(document.createElement('a'));
    modalCloseAElement.attr('href', '#');
    modalCloseAElement.addClass('tl-icon tl-icon-times');

    // modalCloseElement.append(modalCloseAElement);

    modalDialogElement.append(modalContentElement);

    modalBgElement.append(modalDialogElement);

    modalElement.append(modalBgElement);

    var bodyElement = angular.element(document.querySelector('body'));
    if (bodyElement) bodyElement.append(modalElement);

    return {
      modalBgElement: modalBgElement,
      modalElement: modalElement,
      modalContentElement: modalContentElement
    };
  }

  /**
   * @param {DOMElement} modalElement
   * @param {Object} [options]
   * @param {String} [options.openOn] - direction to open the panel
   */
  function getOrCreateModalBgElement(modalElement, options) {
    options = options || {};

    var bodyElement = angular.element(document.querySelector('body'));
    var existingModalBgElement = document.querySelector('.angular-panel-bg');

    if (existingModalBgElement) return angular.element(existingModalBgElement);

    var modalBgElement = angular.element(document.createElement('div'));
    modalBgElement.addClass('angular-panel-bg');
    modalBgElement.addClass('angular-panel-open-' + options.openOn);
    modalBgElement.on('click', function () {
      //close the modal on backgroup clicks
      if (options.dismiss) options.dismiss('backdrop click');
    });

    bodyElement.on('keydown keypress', function (event) {
      //close the modal on escape keypress
      if (event.which === 27) {
        // 27 = esc key
        event.preventDefault();

        if (options.dismiss) options.dismiss('escape key press');
      }
    });

    return modalBgElement;
  }

  function closeModalElements(modalElement, modalBgElement) {
    $timeout(function () {
      modalBgElement.removeClass('open');
    });

    $timeout(function () {
      modalElement.remove();
    }, 200);

    var bodyElement = angular.element(document.querySelector('body'));

    bodyElement.off('keydown keypress');
  }

  function openModalElements(modalElement, modalBgElement) {
    $timeout(function () {
      modalBgElement.addClass('open');
    });
  }

  function _createTemplate(newScope, htmlString) {
    var compiledElement = $compile(htmlString)(newScope);
    return compiledElement;
  }

  function _getTemplate(templateUrl) {
    return $http.get(templateUrl);
  }

  return new AngularSlideOutPanel();
}]);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

angular.module('angular-slideout-panel').service('angularSlideOutPanelStack', [function () {
  var AngularPanelStack = function () {
    function AngularPanelStack() {
      _classCallCheck(this, AngularPanelStack);

      this._stack = [];
    }

    _createClass(AngularPanelStack, [{
      key: '_addPanel',
      value: function _addPanel(panel) {
        if (!panel) return;

        this._stack.push(panel);
      }
    }]);

    return AngularPanelStack;
  }();

  return new AngularPanelStack();
}]);